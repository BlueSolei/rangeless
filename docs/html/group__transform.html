<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rangeless::fn: Transform and Adapt</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rangeless::fn
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__transform.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Transform and Adapt</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaae5c24201d765956eb067debdf56d64"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:gaaae5c24201d765956eb067debdf56d64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structrangeless_1_1fn_1_1impl_1_1adapt.html">impl::adapt</a>&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform.html#gaaae5c24201d765956eb067debdf56d64">rangeless::fn::adapt</a> (F fn)</td></tr>
<tr class="memdesc:gaaae5c24201d765956eb067debdf56d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a custom processing-stage function-object.  <a href="group__transform.html#gaaae5c24201d765956eb067debdf56d64">More...</a><br /></td></tr>
<tr class="separator:gaaae5c24201d765956eb067debdf56d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979427b87c75f4d09f0a6db776b47f3b"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga979427b87c75f4d09f0a6db776b47f3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structrangeless_1_1fn_1_1impl_1_1transform.html">impl::transform</a>&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">rangeless::fn::transform</a> (F map_fn)</td></tr>
<tr class="memdesc:ga979427b87c75f4d09f0a6db776b47f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>seq</code> yielding results of applying the transform functions to input-elements.  <a href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">More...</a><br /></td></tr>
<tr class="separator:ga979427b87c75f4d09f0a6db776b47f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406bfcec6a4930bdc714536bf35e7f46"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ga406bfcec6a4930bdc714536bf35e7f46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structrangeless_1_1fn_1_1impl_1_1par__transform.html">impl::par_transform</a>&lt; F, <a class="el" href="structrangeless_1_1fn_1_1impl_1_1std__async.html">impl::std_async</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform.html#ga406bfcec6a4930bdc714536bf35e7f46">rangeless::fn::transform_in_parallel</a> (F map_fn)</td></tr>
<tr class="memdesc:ga406bfcec6a4930bdc714536bf35e7f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelized version of <code><a class="el" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b" title="Create a seq yielding results of applying the transform functions to input-elements.">fn::transform</a></code>  <a href="group__transform.html#ga406bfcec6a4930bdc714536bf35e7f46">More...</a><br /></td></tr>
<tr class="separator:ga406bfcec6a4930bdc714536bf35e7f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9441c1e2ac00c852a64cb35e584b6e1"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Async &gt; </td></tr>
<tr class="memitem:gae9441c1e2ac00c852a64cb35e584b6e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structrangeless_1_1fn_1_1impl_1_1par__transform.html">impl::par_transform</a>&lt; F, Async &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transform.html#gae9441c1e2ac00c852a64cb35e584b6e1">rangeless::fn::transform_in_parallel</a> (F map_fn, Async async)</td></tr>
<tr class="memdesc:gae9441c1e2ac00c852a64cb35e584b6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of <code>transform_in_parallel</code> that uses a user-provided Async (e.g. backed by a fancy work-stealing thread-pool implementation).  <a href="group__transform.html#gae9441c1e2ac00c852a64cb35e584b6e1">More...</a><br /></td></tr>
<tr class="separator:gae9441c1e2ac00c852a64cb35e584b6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaae5c24201d765956eb067debdf56d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaae5c24201d765956eb067debdf56d64">&#9670;&nbsp;</a></span>adapt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrangeless_1_1fn_1_1impl_1_1adapt.html">impl::adapt</a>&lt;F&gt; rangeless::fn::adapt </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a custom processing-stage function-object. </p>
<p>This is somewhat similar to <code><a class="el" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b" title="Create a seq yielding results of applying the transform functions to input-elements.">fn::transform</a></code>, except the correspondence between inputs and outputs is not necessarily 1:1, and instead of taking a single element to transform we take a nullary generator callable <code>gen</code> and use it to fetch however many input elements we need to generate the next output element.</p>
<p>NB: If <code>bool(gen)==false</code>, the next invocation of gen() shall throw <code><a class="el" href="structrangeless_1_1fn_1_1end__seq_1_1exception.html">fn::end_seq::exception</a></code> signaling end-of-inputs.</p>
<div class="fragment"><div class="line">        <span class="keyword">auto</span> my_transform = [](<span class="keyword">auto</span> <a class="code" href="namespacerangeless_1_1fn.html">fn</a>)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="group__transform.html#gaaae5c24201d765956eb067debdf56d64">fn::adapt</a>([<a class="code" href="namespacerangeless_1_1fn.html">fn</a> = std::move(<a class="code" href="namespacerangeless_1_1fn.html">fn</a>)](<span class="keyword">auto</span> gen)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> <a class="code" href="namespacerangeless_1_1fn.html">fn</a>(gen());</div><div class="line">            });</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> my_where = [](<span class="keyword">auto</span> pred)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="group__transform.html#gaaae5c24201d765956eb067debdf56d64">fn::adapt</a>([pred = std::move(pred)](<span class="keyword">auto</span> gen)</div><div class="line">            {</div><div class="line">                <span class="keyword">auto</span> x = gen();</div><div class="line">                <span class="keywordflow">while</span>(!pred(x)) {</div><div class="line">                    x = gen();</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> x;</div><div class="line">            });</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> my_take_while = [](<span class="keyword">auto</span> pred)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="group__transform.html#gaaae5c24201d765956eb067debdf56d64">fn::adapt</a>([pred = std::move(pred)](<span class="keyword">auto</span> gen)</div><div class="line">            {</div><div class="line">                <span class="keyword">auto</span> x = gen();</div><div class="line">                <span class="keywordflow">return</span> pred(x) ? std::move(x) : <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::end_seq();</div><div class="line">            });</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> my_intersperse = [](<span class="keyword">auto</span> delim)</div><div class="line">        {</div><div class="line"><span class="preprocessor">#if 1</span></div><div class="line">            <span class="keywordflow">return</span> [delim = std::move(delim)](<span class="keyword">auto</span> inputs)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> <a class="code" href="group__io.html#gab5624a94f8786cb370675a260eb51928">fn::seq</a>([  delim, </div><div class="line">                                 inputs = std::move(inputs), </div><div class="line">                                     it = inputs.end(), </div><div class="line">                                started = <span class="keyword">false</span>, </div><div class="line">                                   flag = <span class="keyword">false</span>]() <span class="keyword">mutable</span></div><div class="line">                {</div><div class="line">                    <span class="keywordflow">if</span>(!started) {</div><div class="line">                        started = <span class="keyword">true</span>;</div><div class="line">                        it = inputs.begin();</div><div class="line">                    }</div><div class="line">                    <span class="keywordflow">return</span> it == inputs.end() ? <a class="code" href="structrangeless_1_1fn_1_1end__seq.html">fn::end_seq</a>()</div><div class="line">                         :     (flag = !flag) ? std::move(*it++)</div><div class="line">                         :                      delim;</div><div class="line">                });</div><div class="line">            };</div><div class="line">            </div><div class="line"><span class="preprocessor">#elif 0 // or</span></div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> [delim = std::move(delim)](<span class="keyword">auto</span> inputs)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> std::move(inputs)</div><div class="line">              % <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a>([delim](<span class="keyword">auto</span> inp)</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">return</span> std::array&lt;decltype(inp), 2&gt;{{ std::move(inp), delim }};</div><div class="line">                })</div><div class="line">              % <a class="code" href="group__concat.html#gac6a26ae2179802d847910eaa00daac7f">fn::concat</a>()</div><div class="line">              % <a class="code" href="group__filtering.html#gac37eb5de357758627f1f48e045645f92">fn::drop_last</a>(); <span class="comment">// drop trailing delim</span></div><div class="line">            };</div><div class="line"></div><div class="line"><span class="preprocessor">#else // or</span></div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="group__transform.html#gaaae5c24201d765956eb067debdf56d64">fn::adapt</a>([delim, flag = <span class="keyword">false</span>](<span class="keyword">auto</span> gen) <span class="keyword">mutable</span></div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span>           !gen ? <a class="code" href="structrangeless_1_1fn_1_1end__seq.html">fn::end_seq</a>() </div><div class="line">                     : (flag = !flag) ? gen() </div><div class="line">                     :                  delim;</div><div class="line">            });</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        };</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">auto</span> my_inclusive_scan = []</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="group__transform.html#gaaae5c24201d765956eb067debdf56d64">fn::adapt</a>([sum = 0](<span class="keyword">auto</span> gen) <span class="keyword">mutable</span></div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> sum += gen();</div><div class="line">            });</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> res = </div><div class="line">            <a class="code" href="group__io.html#gab5624a94f8786cb370675a260eb51928">fn::seq</a>([i = 0]() <span class="keyword">mutable</span></div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> i++;</div><div class="line">            })                  <span class="comment">// 0,1,2,3,...</span></div><div class="line"></div><div class="line">          % my_where([](<span class="keywordtype">int</span> x)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> x &gt;= 3; </div><div class="line">            })                  <span class="comment">// 3,4,5,...</span></div><div class="line"></div><div class="line">          % my_take_while([](<span class="keywordtype">int</span> x)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> x &lt;= 5;</div><div class="line">            })                  <span class="comment">// 3,4,5</span></div><div class="line"></div><div class="line">          % my_intersperse(-1)  <span class="comment">// 3,-1,4,-1,5</span></div><div class="line"></div><div class="line">          % my_transform([](<span class="keywordtype">int</span> x)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">return</span> x + 1;</div><div class="line">            })                  <span class="comment">// 4,0,5,0,6</span></div><div class="line"></div><div class="line">          % my_inclusive_scan() <span class="comment">// 4,4,9,9,15</span></div><div class="line"></div><div class="line">          % <a class="code" href="group__to__vec.html#gaed63bb21cc79709c4d88a9d385a13aaf">fn::to_vector</a>();</div><div class="line"></div><div class="line">        VERIFY((res == vec_t{{4, 4, 9, 9, 15}}));</div></div><!-- fragment --><p>A more realistic example: suppose you have a pipeline transforming inputs to outputs in parallel, and you want to compress the output, but the outputs are small and compressing them individually would be ineffective, and you want to serialize the incoming results into a buffer of some minimum size, e.g. 100kb, before passing it to the compressing stage. </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> make_result     = [](std::string s){ <span class="keywordflow">return</span> s; };</div><div class="line">  <span class="keyword">auto</span> compress_block  = [](std::string s){ <span class="keywordflow">return</span> s; };</div><div class="line">  <span class="keyword">auto</span> write_to_ostr   = [](std::string s){ std::cout &lt;&lt; s; };</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacerangeless_1_1fn.html">fn</a> = <a class="code" href="namespacerangeless_1_1fn.html">rangeless::fn</a>;</div><div class="line">  <span class="keyword">using</span> fn::operators::operator%;</div><div class="line"></div><div class="line">  <a class="code" href="group__io.html#gab5624a94f8786cb370675a260eb51928">fn::seq</a>([&amp;]() -&gt; std::string</div><div class="line">  {</div><div class="line">      std::string line;</div><div class="line">      <span class="keywordflow">return</span> std::getline(std::cin, line) ? std::move(line) </div><div class="line">                                          : <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::end_seq();</div><div class="line">  })</div><div class="line"></div><div class="line">% <a class="code" href="group__transform.html#ga406bfcec6a4930bdc714536bf35e7f46">fn::transform_in_parallel</a>(make_result)</div><div class="line"></div><div class="line">% <a class="code" href="group__transform.html#gaaae5c24201d765956eb067debdf56d64">fn::adapt</a>([](<span class="keyword">auto</span> get_next)</div><div class="line">  { </div><div class="line">      std::ostringstream buf{};</div><div class="line"></div><div class="line">      <span class="keywordflow">while</span>(get_next &amp;&amp; buf.tellp() &lt; 100000) {</div><div class="line">          buf &lt;&lt; get_next();</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> buf.tellp() ? buf.str() : <a class="code" href="structrangeless_1_1fn_1_1end__seq.html">fn::end_seq</a>();</div><div class="line">  })</div><div class="line"></div><div class="line">% <a class="code" href="group__transform.html#ga406bfcec6a4930bdc714536bf35e7f46">fn::transform_in_parallel</a>(compress_block)</div><div class="line"></div><div class="line">% <a class="code" href="group__folding.html#ga8568617f52b0e084f2c1303d71705b69">fn::for_each</a>(write_to_ostr);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="fn_8hpp_source.html#l04000">4000</a> of file <a class="el" href="fn_8hpp_source.html">fn.hpp</a>.</p>

</div>
</div>
<a id="ga979427b87c75f4d09f0a6db776b47f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979427b87c75f4d09f0a6db776b47f3b">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrangeless_1_1fn_1_1impl_1_1transform.html">impl::transform</a>&lt;F&gt; rangeless::fn::transform </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>map_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <code>seq</code> yielding results of applying the transform functions to input-elements. </p>
<p>Returns a unary function-object, which will capture the arg by value and return an adapted <code>seq&lt;...&gt;</code> which will yield results of invoking <code>map_fn</code> on the elements (passed by value) of arg. See <code><a class="el" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210" title="Filter elements.">fn::where</a></code> for an example. </p>

<p class="definition">Definition at line <a class="el" href="fn_8hpp_source.html#l04013">4013</a> of file <a class="el" href="fn_8hpp_source.html">fn.hpp</a>.</p>

</div>
</div>
<a id="ga406bfcec6a4930bdc714536bf35e7f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga406bfcec6a4930bdc714536bf35e7f46">&#9670;&nbsp;</a></span>transform_in_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrangeless_1_1fn_1_1impl_1_1par__transform.html">impl::par_transform</a>&lt;F, <a class="el" href="structrangeless_1_1fn_1_1impl_1_1std__async.html">impl::std_async</a>&gt; rangeless::fn::transform_in_parallel </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>map_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallelized version of <code><a class="el" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b" title="Create a seq yielding results of applying the transform functions to input-elements.">fn::transform</a></code> </p>
<p>Requires <code>#define RANGELESS_FN_ENABLE_PARALLEL 1</code> before <code>#include <a class="el" href="fn_8hpp.html">fn.hpp</a></code> because it brings in "heavy" STL <code>#include</code>s (<code>&lt;future&gt;</code> and <code>&lt;thread&gt;</code>).</p>
<p><code>queue_capacity</code> is the maximum number of simultaneosly-running <code>std::async</code>-tasks, each executing a single invocation of <code>map_fn</code>.</p>
<p>NB: if the execution time of <code>map_fn</code> is highly variable, having higher capacity may help, such that tasks continue to execute while we're blocked waiting on a result from a long-running task.</p>
<p>NB: If the tasks are too small compared to overhead of running as async-task, it may be helpful to batch them (see <code><a class="el" href="group__grouping.html#ga274ee29d818836d6ba1e8b0b862b85df" title="Group adjacent elements into chunks of specified size.">fn::in_groups_of</a></code>), have <code>map_fn</code> produce a vector of outputs from a vector of inputs, and <code><a class="el" href="group__concat.html#gac6a26ae2179802d847910eaa00daac7f" title="Flatten the result of group_all_by or group_adjacent_by.">fn::concat</a></code> the outputs.</p>
<p><code>map_fn</code> is required to be thread-safe.</p>
<p>NB: the body of the <code>map_fn</code> would normally compute the result in-place, but it could also, for example, execute a subprocess do it, or offload it to a cloud or a compute-farm, etc.</p>
<hr/>
<p> Q: Why do we need this? We have parallel <code>std::transform</code> and <code>std::transform_reduce</code> in c++17?</p>
<p>A: Parallel <code>std::transform</code> requires a multi-pass <code>ForwardRange</code> rather than <code>InputRange</code>, and <code>std::terminate</code>s if any of the tasks throws. <code>std::transform_reduce</code> requires <code>ForwardRange</code> and type-symmetric, associative, and commutative <code>BinaryOp</code> (making it next-to-useless).</p>
<div class="fragment"><div class="line"><span class="comment">// Example: implement parallelized gzip compressor (a-la pigz)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define RANGELESS_FN_ENABLE_PARALLEL 1</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="fn_8hpp.html">fn.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;util/compress/stream_util.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="aln__filter_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span>&amp; istr = std::cin;</div><div class="line">    <span class="keyword">auto</span>&amp; ostr = std::cout;</div><div class="line"></div><div class="line">    istr.exceptions(std::ios::badbit);</div><div class="line">    ostr.exceptions(std::ios::failbit | std::ios::badbit);</div><div class="line"></div><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacerangeless_1_1fn.html">fn</a> = <a class="code" href="namespacerangeless_1_1fn.html">rangeless::fn</a>;</div><div class="line">    <span class="keyword">using</span> fn::operators::operator%;</div><div class="line">    <span class="keyword">using</span> bytes_t = std::string;</div><div class="line"></div><div class="line">    <a class="code" href="group__io.html#gab5624a94f8786cb370675a260eb51928">fn::seq</a>([&amp;istr]() -&gt; bytes_t</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> buf = bytes_t(1000000UL, <span class="charliteral">&#39;\0&#39;</span>);</div><div class="line">        istr.read(&amp;buf[0], std::streamsize(buf.size()));</div><div class="line">        buf.resize(<span class="keywordtype">size_t</span>(istr.gcount()));</div><div class="line">        <span class="keywordflow">return</span> !buf.empty() ? std::move(buf) : <a class="code" href="namespacerangeless_1_1fn.html">fn</a>::end_seq();</div><div class="line">    })</div><div class="line">  </div><div class="line">  % <a class="code" href="group__transform.html#ga406bfcec6a4930bdc714536bf35e7f46">fn::transform_in_parallel</a>([](bytes_t buf) -&gt; bytes_t</div><div class="line">    {</div><div class="line">        <span class="comment">// compress the block.</span></div><div class="line">        std::ostringstream local_ostr;</div><div class="line">        ncbi::CCompressOStream{</div><div class="line">            local_ostr,</div><div class="line">            ncbi::CCompressOStream::eGZipFile } &lt;&lt; buf;</div><div class="line">        <span class="keywordflow">return</span> local_ostr.str();</div><div class="line"></div><div class="line">    }).queue_capacity( std::thread::hardware_concurrency() )</div><div class="line"></div><div class="line">  % <a class="code" href="group__folding.html#ga8568617f52b0e084f2c1303d71705b69">fn::for_each</a>([&amp;ostr](bytes_t buf)</div><div class="line">    {</div><div class="line">        ostr.write(buf.data(), std::streamsize(buf.size()));</div><div class="line">    });</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> istr.eof() &amp;&amp; !istr.bad() ? 0 : 1;</div><div class="line">}</div></div><!-- fragment --><p>See an similar examples using <a href="https://medium.com/cat-dev-urandom/simplifying-parallel-applications-for-c-an-example-parallel-bzip2-using-raftlib-with-performance-f69cc8f7f962">RaftLib</a> or <a href="https://software.intel.com/en-us/node/506068">TBB</a> </p>

<p class="definition">Definition at line <a class="el" href="fn_8hpp_source.html#l04128">4128</a> of file <a class="el" href="fn_8hpp_source.html">fn.hpp</a>.</p>

</div>
</div>
<a id="gae9441c1e2ac00c852a64cb35e584b6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9441c1e2ac00c852a64cb35e584b6e1">&#9670;&nbsp;</a></span>transform_in_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Async &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrangeless_1_1fn_1_1impl_1_1par__transform.html">impl::par_transform</a>&lt;F, Async&gt; rangeless::fn::transform_in_parallel </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>map_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Async&#160;</td>
          <td class="paramname"><em>async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of <code>transform_in_parallel</code> that uses a user-provided Async (e.g. backed by a fancy work-stealing thread-pool implementation). </p>
<p><code>Async</code> is a unary invokable having the following signature: <code>template&lt;typename NullaryInvokable&gt; operator()(NullaryInvokable job) const -&gt; std::future&lt;decltype(job())&gt;</code></p>
<p>NB: <code>Async</code> must be copy-constructible (may be passed via <code>std::ref</code> as appropriate).</p>
<p>A single-thread pool can be used to offload the transform-stage to a separate thread if <code>transform</code> is not parallelizeable.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> res2 = </div><div class="line">    std::vector{{1,2,3,4,5}} <span class="comment">// can be an InputRange</span></div><div class="line"></div><div class="line">  % <a class="code" href="group__transform.html#ga406bfcec6a4930bdc714536bf35e7f46">fn::transform_in_parallel</a>([](<span class="keyword">auto</span> x)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::to_string(x);</div><div class="line">    },</div><div class="line">    [&amp;my_thread_pool](<span class="keyword">auto</span> job) -&gt; std::future&lt;decltype(job())&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> my_thread_pool.enqueue(std::move(job));</div><div class="line">    }).queue_capacity(10)</div><div class="line"></div><div class="line">  % <a class="code" href="group__folding.html#ga189f20f64389ca4d2d98b73127968f18">fn::foldl_d</a>([](std::string out, std::string in)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> std::move(out) + <span class="stringliteral">&quot;,&quot;</span> + in;</div><div class="line">    });</div><div class="line">VERIFY(res2 == <span class="stringliteral">&quot;,1,2,3,4,5&quot;</span>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="fn_8hpp_source.html#l04164">4164</a> of file <a class="el" href="fn_8hpp_source.html">fn.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
