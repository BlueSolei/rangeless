<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rangeless::fn: rangeless::fn</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rangeless::fn
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespacerangeless_1_1fn.html" title="LINQ -like library of higher-order functions for data manipulation.">rangeless::fn</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><code>range</code>-free LINQ-like library of higher-order functions for manipulation of containers and lazy input-sequences.</h2>
<ul>
<li>Reduce the amount of mutable state.</li>
<li>Flatten control-flow.</li>
<li>Lessen the need to deal with iterators directly.</li>
<li>Make the code more expressive and composeable.</li>
</ul>
<p>This library is intended for moderate to advanced-level c++ programmers that like the idea of c++ <code>ranges</code>, but can't use them for various reasons (high complexity, compilation overhead, debug-build performance, size of the library, etc).</p>
<p>### Simple examples </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacerangeless_1_1fn.html">fn</a> = <a class="code" href="namespacerangeless_1_1fn.html">rangeless::fn</a>;</div><div class="line"><span class="keyword">using</span> fn::operators::operator%;   <span class="comment">// arg % f % g % h; // h(g(f(std::forward&lt;Arg&gt;(arg))));</span></div><div class="line"><span class="keyword">using</span> fn::operators::operator%=;  <span class="comment">// arg %= fn;       // arg = fn(std::move(arg));</span></div><div class="line"></div><div class="line">employees %= <a class="code" href="group__ordering.html#gaae21820457a98e1860d67e599638c6e1">fn::sort_by</a>([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e){ <span class="keywordflow">return</span> std::tie(e.last_name, e.first_name); });</div><div class="line">             <span class="comment">// this returns a unary function xs-&gt;xs that sorts by the given predicate.</span></div><div class="line"></div><div class="line">employees %= <a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">fn::where</a>([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e){ <span class="keywordflow">return</span> e.last_name != <span class="stringliteral">&quot;Doe&quot;</span>; });</div><div class="line">             <span class="comment">// say Good Riddance to the erase-remove idiom and iterate-erase loops.</span></div><div class="line"></div><div class="line">employees %= <a class="code" href="group__ordering.html#ga30d5a61dda81290e8775bec161982312">fn::take_top_n_by</a>(10, [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e){ <span class="keywordflow">return</span> e.years_onboard; });</div><div class="line"></div><div class="line"><span class="comment">// or </span></div><div class="line"></div><div class="line">employees = std::move(employees)</div><div class="line">          % <a class="code" href="group__ordering.html#gaae21820457a98e1860d67e599638c6e1">fn::sort_by</a>(           [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e){ <span class="keywordflow">return</span> std::tie(e.last_name, e.first_name); })</div><div class="line">          % <a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">fn::where</a>(             [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e){ <span class="keywordflow">return</span> e.last_name != <span class="stringliteral">&quot;Doe&quot;</span>; })</div><div class="line">          % <a class="code" href="group__ordering.html#ga30d5a61dda81290e8775bec161982312">fn::take_top_n_by</a>(10,  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e){ <span class="keywordflow">return</span> e.years_onboard; });</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// </span></div><div class="line">    <span class="comment">// Top-5 most frequent words among the words of the same length.</span></div><div class="line">    <span class="comment">//</span></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> my_isalnum = [](<span class="keyword">const</span> <span class="keywordtype">int</span> ch)</div><div class="line">    {    </div><div class="line">        <span class="keywordflow">return</span> std::isalnum(ch) || ch == <span class="charliteral">&#39;_&#39;</span>; </div><div class="line">    };   </div><div class="line"></div><div class="line">    <span class="keyword">using</span> counts_t = std::map&lt;std::string, size_t&gt;;</div><div class="line"></div><div class="line">    <a class="code" href="group__view.html#ga9243f1562b82e61f7554101d304a41de">fn::from</a>(</div><div class="line">        std::istreambuf_iterator&lt;char&gt;(istr.rdbuf()),</div><div class="line">        std::istreambuf_iterator&lt;char&gt;{})</div><div class="line"></div><div class="line">      % <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a>([](<span class="keyword">const</span> <span class="keywordtype">char</span> c) <span class="comment">// tolower</span></div><div class="line">        {    </div><div class="line">            <span class="keywordflow">return</span> (<span class="charliteral">&#39;A&#39;</span> &lt;= c &amp;&amp; c &lt;= <span class="charliteral">&#39;Z&#39;</span>) ? char(c - (<span class="charliteral">&#39;Z&#39;</span> - <span class="charliteral">&#39;z&#39;</span>)) : c; </div><div class="line">        })   </div><div class="line"></div><div class="line">      % <a class="code" href="group__grouping.html#ga95a5c85e062778a92a1d3e689109d6c9">fn::group_adjacent_by</a>(my_isalnum)</div><div class="line"></div><div class="line"><span class="preprocessor">#if 0</span></div><div class="line">        <span class="comment">// build word-&gt;count map</span></div><div class="line">      % <a class="code" href="group__folding.html#ga189f20f64389ca4d2d98b73127968f18">fn::foldl_d</a>([&amp;](counts_t out, <span class="keyword">const</span> std::string&amp; in)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span>(my_isalnum(in.front())) {</div><div class="line">                ++out[ in ];</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> std::move(out);</div><div class="line">        })</div><div class="line">#<span class="keywordflow">else</span></div><div class="line">        <span class="comment">// alternatively:</span></div><div class="line">      % <a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">fn::where</a>([&amp;](<span class="keyword">const</span> std::string&amp; s)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> my_isalnum(s.front());</div><div class="line">        })</div><div class="line">      % <a class="code" href="group__to__vec.html#ga7a6c6551c510a7904298887a507bb35b">fn::counts</a>() <span class="comment">// map:word-&gt;count</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">      % <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a>(</div><div class="line">              <a class="code" href="group__ordering.html#ga30d5a61dda81290e8775bec161982312">fn::take_top_n_by</a>(5UL, fn::by::second{}))</div><div class="line"></div><div class="line">      % <a class="code" href="group__concat.html#gac6a26ae2179802d847910eaa00daac7f">fn::concat</a>()</div><div class="line"></div><div class="line">      % <a class="code" href="group__folding.html#ga8568617f52b0e084f2c1303d71705b69">fn::for_each</a>([](<span class="keyword">const</span> counts_t::value_type&amp; kv)</div><div class="line">        {    </div><div class="line">            std::cerr &lt;&lt; kv.first &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; kv.second &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        })   </div><div class="line">      ;    </div><div class="line"></div><div class="line">    <span class="comment">// compilation time:</span></div><div class="line">    <span class="comment">// &gt;&gt;time g++ -I ../include/ -std=c++14 -o test.o -c test.cpp</span></div><div class="line">    <span class="comment">// real   0m1.176s</span></div><div class="line">    <span class="comment">// user   0m1.051s</span></div><div class="line">    <span class="comment">// sys    0m0.097s</span></div></div><!-- fragment --><p>See <a href="calendar_8cpp_source.html">calendar.cpp</a> vs. <a href="https://github.com/BartoszMilewski/Calendar/blob/master/Main.hs">Haskell</a> vs. <a href="https://github.com/ericniebler/range-v3/blob/master/example/calendar.cpp">range-v3 implementation</a>.</p>
<p>See <a href="aln__filter_8cpp_source.html">aln_filter.cpp</a> for more advanced examples of use.</p>
<p>See <a href="https://ast-al.github.io/rangeless/docs/html/namespacerangeless_1_1fn.html">full documentation</a>.</p>
<h3>Features</h3>
<ul>
<li>Portable c++11. (examples are c++14)</li>
<li>Single-header.</li>
<li>Minimal standard library dependencies.</li>
<li>No inheritance, polymorphism, type-erasures, ADL, advanced metaprogramming, enable_ifs, concepts, preprocessor magic, arcane programming techniques (for some definition of arcane), or compiler-specific workarounds.</li>
<li>Low <code>#include</code> and compile-time overhead.</li>
<li>Enables trivial parallelization (see <a href="https://ast-al.github.io/rangeless/docs/html/group__transform.html"><code>fn::transform_in_parallel</code></a>).</li>
<li>Allows for trivial extension of functionality (see <a href="https://ast-al.github.io/rangeless/docs/html/group__transform.html"><code>fn::adapt</code></a>).</li>
</ul>
<h3>Minimum supported compilers: MSVC-19.15, GCC-4.9.3, clang-3.7, ICC-18</h3>
<p>This is not a range library, like <code>range-v3</code>, as it is centered around value-semantics rather than reference-semantics. This library does not know or deal with the multitude of range concepts; rather, it deals with data transformations via higher-order functions. It differentiates between two types of inputs: a <code>Container</code> and a lazy <code>seq&lt;NullaryInvokable&gt;</code> satisfying single-pass forward-only <code>InputRange</code> semantics (also known as a data-stream). Most of the function-objects in this library have two overloads of <code>operator()</code> respectively. Rather than composing views over ranges as with <code>range-v3</code>, <code>operator()</code>s take inputs by value, operate on it eagerly or compose a lazy <code>seq</code>, as appropriate (following the Principle of least astonishment), and return the result by value (with move-semantics) to the next stage.</p>
<p>E.g.</p><ul>
<li><code>fn::where</code><ul>
<li>given a container, passed by rvalue, returns the same container filtered to elements satisfying the predicate.</li>
<li>given a container, passed by lvalue-reference, returns a copy of the container with elements satisfying the predicate.</li>
<li>given a <code>seq</code>, passed by value, composes and returns a <code>seq</code> that will skip the elements not satisfying the predicate.</li>
</ul>
</li>
<li><code>fn::sort</code><ul>
<li>given a container, passed by value, returns the sorted container.</li>
<li>given a <code>seq</code>, passed by value, moves elements into a <code>std::vector</code>, and delegates to the above.</li>
</ul>
</li>
<li><code>fn::transform</code><ul>
<li>given a <code>seq</code>, passed by value, returns a <code>seq</code> wrapping a composition of the transform-function over the underlying <code>NullaryInvokable</code>.</li>
<li>given a container, passed by value, wraps it as <code>seq</code> and delegates to the above.</li>
</ul>
</li>
</ul>
<p>Some functions in this library internally buffer elements, as appropriate, with single-pass streaming inputs, whereas <code>range-v3</code>, on the other hand, imposes multipass ForwardRange or stronger requirement on the inputs in situations that would otherwise require buffering. This makes this library conceptually more similar to UNIX pipelines than to c++ ranges.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operations  </th><th class="markdownTableHeadNone">Buffering behavior  </th><th class="markdownTableHeadNone">Laziness   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fn::group_adjacent_by</code>, <code>fn::in_groups_of</code>  </td><td class="markdownTableBodyNone">buffer elements of the incoming group  </td><td class="markdownTableBodyNone">lazy   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fn::unique_all_by</code>  </td><td class="markdownTableBodyNone">buffer unique keys of elements seen so far  </td><td class="markdownTableBodyNone">lazy   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fn::drop_last</code>, <code>fn::sliding_window</code>  </td><td class="markdownTableBodyNone">buffer a queue of last <code>n</code> elements  </td><td class="markdownTableBodyNone">lazy   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fn::transform_in_parallel</code>  </td><td class="markdownTableBodyNone">buffer a queue of <code>n</code> executing async-tasks  </td><td class="markdownTableBodyNone">lazy   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fn::group_all_by</code>, <code>fn::sort_by</code>, <code>fn::lazy_sort_by</code>, <code>fn::reverse</code>, <code>fn::to_vector</code>  </td><td class="markdownTableBodyNone">buffer all elements  </td><td class="markdownTableBodyNone">eager   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fn::take_last</code>  </td><td class="markdownTableBodyNone">buffer a queue of last <code>n</code> elements  </td><td class="markdownTableBodyNone">eager   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fn::where_max_by</code>, <code>fn::where_min_by</code>  </td><td class="markdownTableBodyNone">buffer maximal/minimal elements as seen so-far  </td><td class="markdownTableBodyNone">eager   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>fn::take_top_n_by</code>  </td><td class="markdownTableBodyNone">buffer top <code>n</code> elements as seen so-far  </td><td class="markdownTableBodyNone">eager   </td></tr>
</table>
<h3>Signaling <code>end-of-sequence</code> from a generator-function</h3>
<p>More often than not a generator-function that yields a sequence of values will not be an infinite Fibonacci sequence, but rather some bounded sequence of objects, either from a file, a socket, a database query, etc, so we need to be able to signal end-of-sequence. On way to do it is to yield elements wrapped in <code>std::unique_ptr</code> or <code>std::optional</code>: </p><div class="fragment"><div class="line">  <a class="code" href="group__io.html#gab5624a94f8786cb370675a260eb51928">fn::seq</a>([]() -&gt; std::unique_ptr&lt;...&gt; { ... })</div><div class="line">% <a class="code" href="group__filtering.html#ga1b8fd02fe6abd5defa5f5a6839e5b614">fn::take_while</a>([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> bool(x); })</div><div class="line">% <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a>(fn::get::dereferenced{})</div><div class="line">% ...</div></div><!-- fragment --><p> If your value-type has an "empty" state interpretable as end-of-inputs, you can use the value-type directly without wrapping.</p>
<p>If you don't care about incurring an exception-handling overhead once per whole seq, there's a simpler way of doing it: just return <code>fn::end_seq()</code> from the generator function (e.g. see my_intersperse example). This throws end-of-sequence exception that is caught under the hood (python-style). If you are in <code>-fno-exceptions</code> land, then this method is not for you.</p>
<h3>Summary of different ways of passing inputs</h3>
<div class="fragment"><div class="line">      <a class="code" href="group__io.html#gab5624a94f8786cb370675a260eb51928">fn::seq</a>([]{ ... }) % ... <span class="comment">// as input-range from a nullary invokable</span></div><div class="line"></div><div class="line">          std::move(vec) % ... <span class="comment">// pass a container by-move</span></div><div class="line">                    vec  % ... <span class="comment">// pass by-copy</span></div><div class="line"></div><div class="line">           <a class="code" href="group__view.html#ga9243f1562b82e61f7554101d304a41de">fn::from</a>(vec) % ... <span class="comment">// as move-view yielding elements by-move (std::move will make copies iff vec is const)</span></div><div class="line">          <a class="code" href="group__view.html#ga2ca6028fafc3067870b76bc78684c0fc">fn::cfrom</a>(vec) % ... <span class="comment">// as above, except always take as const-reference / yield by copy</span></div><div class="line">           <a class="code" href="group__io.html#ga30da17b10bf0974dc17153792de3c3af">fn::refs</a>(vec) % ... <span class="comment">// as seq taking vec by reference and yielding reference-wrappers</span></div><div class="line"></div><div class="line"><a class="code" href="group__view.html#ga9243f1562b82e61f7554101d304a41de">fn::from</a>(it_beg, it_end) % ... <span class="comment">// as a move-view into range (std::move will make copies iff const_iterator)</span></div><div class="line">  <a class="code" href="group__view.html#ga9243f1562b82e61f7554101d304a41de">fn::from</a>(beg_end_pair) % ... <span class="comment">// as above, as std::pair of iterators</span></div></div><!-- fragment --><p> Note: <code>fn::from</code> can also be used to adapt an lvalue-reference to an <code>Iterable</code> that implements <code>begin()</code> and <code>end()</code> as free-functions rather than methods.</p>
<h3>Discussion</h3>
<p>There seems to be a lot of misunderstanding about the intended use-cases for this style of coding.</p>
<p>Many programmers after getting introduced to toy examples get an impression that the intended usage is "to express the intent" or "better syntax" or to "separate the concerns", etc.</p>
<p>Others look at the toy examples and point out that they could be straightforwardly written as normal imperative code, and I tend to agree with them: Never write a code like: </p><div class="fragment"><div class="line">  std::move(xs)</div><div class="line">% <a class="code" href="group__filtering.html#ga85f0d030462ff19ba023f92d2b111210">fn::where</a>(     [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> x % 2 == 0; })</div><div class="line">% <a class="code" href="group__transform.html#ga979427b87c75f4d09f0a6db776b47f3b">fn::transform</a>( [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> x * x; }</div><div class="line">% <a class="code" href="group__folding.html#ga8568617f52b0e084f2c1303d71705b69">fn::for_each</a>(  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { std::cout &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; })</div></div><!-- fragment --><p>, if it can be written simply as </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : xs)</div><div class="line">    <span class="keywordflow">if</span>(x % 2 == 0)</div><div class="line">        std::cerr &lt;&lt; x*x &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div></div><!-- fragment --><p> If you are doing "functional style" for no good reason, you are doing it wrong - there's no value-added and you are paiyng compile-time, debugging-layers, and possibly run-time overhead.</p>
<p>There are some scenarios where functional-style is useful:</p>
<h4>Const-correctness.</h4>
<p>By this I mean: when an lvalue is in the process of being built, it should be considered write only; when it is is being used, it should be read-only (declared const and enforced by the compiler, unless the intent is to <code>std::move</code> it). e.g. a contrived example </p><div class="fragment"><div class="line">map&lt;std::string, size_t&gt; word_counts{};</div><div class="line"></div><div class="line"><span class="comment">// modify the map of word-counts...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// ... many of code-lines later, that may or may not have modified word_counts...</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// access word_counts</span></div></div><!-- fragment --><p> If <code>word_counts</code> could be declared const, you could ignore all the code that may-or-may-not modify word_counts between declaration and usage, e.g.: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> word_counts = words % fn::fold_d([](map&lt;std::string, size_t&gt; m, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; word)</div><div class="line">{</div><div class="line">    ++m[word];</div><div class="line">    <span class="keywordflow">return</span> std::move(m);</div><div class="line">};</div></div><!-- fragment --><p>Another code-pattern for this is immediately-executed-lambda. </p><div class="fragment"><div class="line"><span class="keyword">const</span> X x = [&amp;]</div><div class="line">{</div><div class="line">    X x{}; <span class="comment">// this shadows the outside-x above, and it&#39;s GOOD, </span></div><div class="line">           <span class="comment">// as we don&#39;t want to accidently access it here.</span></div><div class="line"></div><div class="line">    <span class="comment">// build X...</span></div><div class="line">    <span class="keywordflow">return</span> x;</div><div class="line">}();</div></div><!-- fragment --><h4>Reduction of mutable state.</h4>
<p>Non-composeable API force the programmer to declare mutable state that really should be temporary. e.g. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> values = get_values(); <span class="comment">// has to be non-const, because will sort</span></div><div class="line"><a class="code" href="group__ordering.html#gaec02a6adf83765e9a0a51d3bafe68354">std::sort</a>(values.begin(), values.end());</div></div><!-- fragment --><p> whereas a composeable API does not necessitate a mutation of an lvalue: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> sorted_values = get_values() % <a class="code" href="group__ordering.html#gaec02a6adf83765e9a0a51d3bafe68354">fn::sort</a>();</div></div><!-- fragment --><h4>Erase-remove idiom.</h4>
<p>If you feel that the idiomatic way of filtering a container is an abomination that should have never seen the light of day, then you'll find this library useful for that alone.</p>
<h4>Transformations over infinite (arbitrarily large) streams (<code>InputRange</code>s)</h4>
<p>The most useful use-case is the scenarios for writing a function or an expression where the input is an infinite stream that you want to manipulate lazily, like a UNIX pipeline, e.g. the above-mentioned <a href="aln__filter_8cpp_source.html">aln_filter.cpp</a>.</p>
<h3>References:</h3>
<ul>
<li><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html">Haskell Data.List</a></li>
<li><a href="https://www.scala-lang.org/api/2.13.x/scala/collection/immutable/LazyList.html">Scala LazyList</a></li>
<li><a href="https://hexdocs.pm/elixir/Stream.html">Elixir Stream</a></li>
<li><a href="https://package.elm-lang.org/packages/elm/core/latest/List">Elm List</a></li>
<li><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">O'Caml List</a></li>
<li><a href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/collections.seq-module-%5bfsharp%5d">F# Collections.Seq</a></li>
<li><a href="https://dlang.org/phobos/std_range.html">D std.range</a></li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Rust Iterator</a></li>
</ul>
<p>c++ -specific (in no particular order):</p><ul>
<li><a href="https://en.cppreference.com/w/cpp/experimental/ranges">c++20 std::ranges</a></li>
<li><a href="https://github.com/tcbrindle/NanoRange">tcbrindle/NanoRange</a></li>
<li><a href="https://github.com/ericniebler/range-v3">ericniebler/range-v3</a></li>
<li><a href="https://github.com/Dobiasd/FunctionalPlus">Dobiasd/FunctionalPlus</a></li>
<li><a href="https://github.com/jscheiny/Streams">jscheiny/Streams</a></li>
<li><a href="https://www.codeproject.com/Articles/512935/A-Lazy-Stream-Implementation-in-Cplusplus">A Lazy Stream Implementation in C++11</a></li>
<li><a href="https://github.com/ryanhaining/cppitertools">ryanhaining/CPPItertools</a></li>
<li><a href="https://github.com/soheilhy/fn">soheilhy/fn</a></li>
<li><a href="https://github.com/LoopPerfect/conduit">LoopPerfect/conduit</a></li>
<li><a href="https://github.com/k06a/boolinq">k06a/boolinq</a></li>
<li><a href="https://github.com/pfultz2/linq">pfultz2/linq</a></li>
<li><a href="https://www.boost.org/doc/libs/1_67_0/libs/range/doc/html/index.html">boost.range</a></li>
<li><a href="https://archive.codeplex.com/?p=cpplinq">cpplinq</a></li>
</ul>
<p>Recommended blogs:</p><ul>
<li><a href="https://ericniebler.com">Eric Niebler</a></li>
<li><a href="https://www.fluentcpp.com">fluent c++</a></li>
<li><a href="https://akrzemi1.wordpress.com">Andrzej's C++ blog</a></li>
<li><a href="https://foonathan.net">foonathan::blog()</a></li>
<li><a href="https://quuxplusone.github.io/blog">quuxplusone</a></li>
<li><a href="https://bartoszmilewski.com">Bartosz Milewski</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
